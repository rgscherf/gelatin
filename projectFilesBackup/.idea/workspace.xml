<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ChangeListManager">
    <list default="true" id="e0ba252f-3175-487e-88d5-0c5695bbda4e" name="Default Changelist" comment="">
      <change afterPath="$PROJECT_DIR$/src/cljs/proto_crawl/entities/actions.cljs" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/src/cljs/proto_crawl/rot_js/astar.cljs" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/src/cljs/proto_crawl/specs/game_state.cljs" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/src/cljs/proto_crawl/specs/pathable.cljs" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/src/cljs/proto_crawl/specs/player.cljs" afterDir="false" />
      <change afterPath="$PROJECT_DIR$/src/cljs/proto_crawl/specs/renderable.cljs" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/deps.edn" beforeDir="false" afterPath="$PROJECT_DIR$/deps.edn" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/cljs/proto_crawl/controls/main.cljs" beforeDir="false" afterPath="$PROJECT_DIR$/src/cljs/proto_crawl/controls/main.cljs" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/cljs/proto_crawl/entities/main.cljs" beforeDir="false" afterPath="$PROJECT_DIR$/src/cljs/proto_crawl/entities/main.cljs" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/cljs/proto_crawl/entities/utils.cljs" beforeDir="false" afterPath="$PROJECT_DIR$/src/cljs/proto_crawl/entities/utils.cljs" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/cljs/proto_crawl/main.cljs" beforeDir="false" afterPath="$PROJECT_DIR$/src/cljs/proto_crawl/main.cljs" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/cljs/proto_crawl/maps/main.cljs" beforeDir="false" afterPath="$PROJECT_DIR$/src/cljs/proto_crawl/maps/main.cljs" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/cljs/proto_crawl/maps/tiles.cljs" beforeDir="false" afterPath="$PROJECT_DIR$/src/cljs/proto_crawl/maps/tiles.cljs" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/cljs/proto_crawl/re_frame/events.cljs" beforeDir="false" afterPath="$PROJECT_DIR$/src/cljs/proto_crawl/re_frame/events.cljs" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/cljs/proto_crawl/re_frame/state.cljs" beforeDir="false" afterPath="$PROJECT_DIR$/src/cljs/proto_crawl/re_frame/state.cljs" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/cljs/proto_crawl/rot_js/pathfinding.cljs" beforeDir="false" afterPath="$PROJECT_DIR$/src/cljs/proto_crawl/rot_js/pathfinding.cljs" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/src/cljs/proto_crawl/view/main.cljs" beforeDir="false" afterPath="$PROJECT_DIR$/src/cljs/proto_crawl/view/main.cljs" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/target/main.js" beforeDir="false" afterPath="$PROJECT_DIR$/target/main.js" afterDir="false" />
      <change beforePath="$PROJECT_DIR$/target/manifest.edn" beforeDir="false" afterPath="$PROJECT_DIR$/target/manifest.edn" afterDir="false" />
    </list>
    <option name="EXCLUDED_CONVERTED_TO_IGNORED" value="true" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="DepsLocalSettings">
    <option name="availableProjects">
      <map>
        <entry>
          <key>
            <ExternalProjectPojo>
              <option name="name" value="proto-crawl" />
              <option name="path" value="$PROJECT_DIR$" />
            </ExternalProjectPojo>
          </key>
          <value>
            <list>
              <ExternalProjectPojo>
                <option name="name" value="proto-crawl" />
                <option name="path" value="$PROJECT_DIR$" />
              </ExternalProjectPojo>
            </list>
          </value>
        </entry>
      </map>
    </option>
    <option name="modificationStamps">
      <map>
        <entry key="$USER_HOME$/.clojure/deps.edn" value="0" />
        <entry key="$PROJECT_DIR$" value="4705787149471" />
        <entry key="$PROJECT_DIR$/deps.edn" value="1001576358" />
        <entry key="/usr/local/Cellar/clojure/1.10.1.469/deps.edn" value="3440790518" />
      </map>
    </option>
    <option name="projectSyncType">
      <map>
        <entry key="$PROJECT_DIR$" value="RE_IMPORT" />
      </map>
    </option>
  </component>
  <component name="ExternalProjectsData">
    <projectState path="$PROJECT_DIR$">
      <ProjectState />
    </projectState>
  </component>
  <component name="ExternalProjectsManager">
    <system id="CLOJURE_DEPS">
      <state>
        <projects_view>
          <tree_state>
            <expand />
            <select />
          </tree_state>
        </projects_view>
      </state>
    </system>
  </component>
  <component name="FileTemplateManagerImpl">
    <option name="RECENT_TEMPLATES">
      <list>
        <option value="HTML File" />
        <option value="ClojureScript Namespace" />
      </list>
    </option>
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
  </component>
  <component name="HighlightingSettingsPerFile">
    <setting file="file://$PROJECT_DIR$/src/cljs/proto_crawl/cube/main.cljs" root0="FORCE_HIGHLIGHTING" />
    <setting file="file://$PROJECT_DIR$/src/cljs/proto_crawl/view/main.cljs" root0="FORCE_HIGHLIGHTING" />
    <setting file="file://$PROJECT_DIR$/deps.edn" root0="FORCE_HIGHLIGHTING" />
    <setting file="file://$PROJECT_DIR$/src/cljs/proto_crawl/rot_js/rng.cljs" root0="FORCE_HIGHLIGHTING" />
    <setting file="file://$PROJECT_DIR$/src/cljs/proto_crawl/main.cljs" root0="FORCE_HIGHLIGHTING" />
    <setting file="file://$PROJECT_DIR$/src/cljs/proto_crawl/entities/main.cljs" root0="FORCE_HIGHLIGHTING" />
    <setting file="file://$PROJECT_DIR$/src/cljs/proto_crawl/maps/tiles.cljs" root0="FORCE_HIGHLIGHTING" />
  </component>
  <component name="IgnoredFileRootStore">
    <option name="generatedRoots">
      <set>
        <option value="$PROJECT_DIR$/.idea" />
      </set>
    </option>
  </component>
  <component name="ProjectId" id="1QbroHWJCScpmKRl3WxgDBdEpF9" />
  <component name="ProjectLevelVcsManager" settingsEditedManually="true">
    <ConfirmationsSetting value="2" id="Add" />
  </component>
  <component name="PropertiesComponent">
    <property name="DefaultHtmlFileTemplate" value="HTML File" />
    <property name="cursive.last.file.extension./Users/rgscherf/projects/games/proto-crawl/src/cljs" value="cljs" />
    <property name="cursive.last.file.extension./Users/rgscherf/projects/games/proto-crawl/src/proto-crawl/cljs" value="cljs" />
    <property name="last_opened_file_path" value="$PROJECT_DIR$/target/resources" />
    <property name="project.structure.last.edited" value="Project" />
    <property name="project.structure.proportion" value="0.0" />
    <property name="project.structure.side.proportion" value="0.0" />
    <property name="settings.editor.selected.configurable" value="preferences.pluginManager" />
  </component>
  <component name="RecentsManager">
    <key name="CopyFile.RECENT_KEYS">
      <recent name="$PROJECT_DIR$/target/resources" />
    </key>
    <key name="MoveFile.RECENT_KEYS">
      <recent name="$PROJECT_DIR$/src/cljs/proto-crawl" />
      <recent name="$PROJECT_DIR$/src/cljs" />
      <recent name="$PROJECT_DIR$/src" />
    </key>
  </component>
  <component name="ReplState" timestamp="1570850035894">{:repl-history {:ide [], :local [], :remote [{:command &quot;(defn pathfind\n  [level start-node end-node]\n  (let [graph (path-graph level start-node)]\n    (if (get graph end-node)\n      (loop [search-node end-node\n             path        [end-node]]\n        (let [node-contents (get graph search-node)]\n          (if (= :start node-contents)\n              (reverse path)\n              (recur node-contents (conj path node-contents)))))\n      \&quot;nope!\&quot;)))&quot;, :offset 392, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(def testmap\n  [[1 1 1 1 1]\n   [9 9 9 9 1]\n   [1 1 9 1 1]\n   [1 1 1 1 9]\n   [1 9 9 9 9]\n   [1 1 1 1 1]])&quot;, :offset 104, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(pathfind testmap [0 0] [4 4])&quot;, :offset 30, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn pathfind\n  [level start-node end-node]\n  (let [graph (path-graph level start-node end-node)]\n    (if (get graph end-node)\n      (loop [search-node end-node\n             path        [end-node]]\n        (let [node-contents (get graph search-node)]\n          (if (= :start node-contents)\n              (reverse path)\n              (recur node-contents (conj path node-contents)))))\n      \&quot;nope!\&quot;)))&quot;, :offset 401, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn path-graph\n  [level start-node end-node]\n  (loop [frontier  [start-node]\n         came-from {start-node :start}]\n    (if (or (empty? frontier)\n            (= end-node (first frontier)))\n      came-from\n      (let [current (first frontier)\n            ns      (remove #(or (nil? (contents level %))\n                                 (= 9 (contents level %)))\n                            (neighbors current))\n            [new-front new-came-from] (evaluate-neighbors current\n                                                          ns\n                                                          frontier\n                                                          came-from)]\n        (recur new-front new-came-from)))))&quot;, :offset 719, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(ns proto-crawl.rot-js.astar\n  (:require [tailrecursion.priority-map :as primap]))&quot;, :offset 82, :ns &quot;cljs.user&quot;} {:command &quot;(primap/priority-map)&quot;, :offset 21, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(let [p (primap/priority-map \&quot;hello\&quot; 1 \&quot;world\&quot; 2)])&quot;, :offset 51, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(let [p (primap/priority-map \&quot;hello\&quot; 1 \&quot;world\&quot; 2)]\n  p)&quot;, :offset 55, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(let [p (primap/priority-map \&quot;hello\&quot; 1 \&quot;world\&quot; 2)]\n  (peek p))&quot;, :offset 62, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(ns proto-crawl.rot-js.astar\n  (:require [tailrecursion.priority-map :as priority]))&quot;, :offset 84, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(let [p (priority/priority-map \&quot;hello\&quot; 1 \&quot;world\&quot; 2)]\n  (peek p))&quot;, :offset 64, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(empty? (priority/priority-map))&quot;, :offset 32, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(empty? (priority/priority-map :hello 1))&quot;, :offset 41, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(empty? (priority/priority-map :hello 1 :world 2))&quot;, :offset 50, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(peek (priority/priority-map :hello 1 :world 2))&quot;, :offset 48, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(first (priority/priority-map :hello 1 :world 2))&quot;, :offset 49, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(first (priority/priority-map :butts 3 :hello 1 :world 2))&quot;, :offset 58, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn evaluate-neighbors\n  [current-node neighbors frontier came-from]\n  (reduce (fn [[new-front new-came] node]\n            (if (nil? (get new-came node))\n              [(assoc new-front node 0)\n               (assoc new-came node current-node)]\n              [new-front new-came]))\n          [frontier came-from]\n          neighbors))&quot;, :offset 336, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn path-graph\n  [level start-node end-node]\n  (loop [frontier  (priority/priority-map start-node 0)\n         came-from {start-node :start}]\n    (if (or (empty? frontier)\n            (= end-node (-&gt; frontier peek first)))\n      came-from\n      (let [current             (-&gt; frontier peek first)\n            ;; TODO give reachable-neighbors a callback fn\n            ;; so passability isn't hardcoded (in practice will check\n            ;; ::p/passable? on nodes).\n            reachable-neighbors (remove #(or (nil? (contents level %)) ;; &lt;-- here\n                                             (= 9 (contents level %)))\n                                        (neighbors current))\n            [new-front new-came-from] (evaluate-neighbors current\n                                                          reachable-neighbors\n                                                          (pop frontier)\n                                                          came-from)]\n        (recur new-front new-came-from)))))&quot;, :offset 1011, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn path-graph\n  [level start-node end-node]\n  (loop [frontier  (priority/priority-map start-node 0)\n         came-from {start-node :start}\n         cost-so-far {start-node 0}]\n    (if (or (empty? frontier)\n            (= end-node (-&gt; frontier peek first)))\n      came-from\n      (let [current             (-&gt; frontier peek first)\n            ;; TODO give reachable-neighbors a callback fn\n            ;; so passability isn't hardcoded (in practice will check\n            ;; ::p/passable? on nodes).\n            reachable-neighbors (remove #(or (nil? (contents level %)) ;; &lt;-- here\n                                             (= 9 (contents level %)))\n                                        (neighbors current))\n            [new-front new-came-from new-cost-so-far] (evaluate-neighbors current\n                                                                          reachable-neighbors\n                                                                          (pop frontier)\n                                                                          came-from\n                                                                          cost-so-far)]\n        (recur new-front new-came-from new-cost-so-far)))))&quot;, :offset 1213, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn evaluate-neighbors\n  [current-node neighbors frontier came-from cost-so-far]\n  (reduce (fn [[new-front new-came new-cost] node]\n            (let [node-cost (inc (get new-cost current-node))]\n              (if (or (nil? (get new-cost node))\n                      (&lt; node-cost (get new-cost node)))\n                [(assoc new-front node node-cost)\n                 (assoc new-came node current-node)\n                 (assoc new-cost node node-cost)]\n                [new-front new-came])))\n          [frontier came-from cost-so-far]\n          neighbors))&quot;, :offset 559, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(pathfind testmap [0 0] [1 2])&quot;, :offset 30, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn evaluate-neighbors\n  [current-node neighbors frontier came-from cost-so-far]\n  (reduce (fn [[new-front new-came new-cost] node]\n            (let [node-cost (inc (get new-cost current-node))]\n              (if (or (nil? (get new-cost node))\n                      (&lt; node-cost (get new-cost node)))\n                [(assoc new-front node node-cost)\n                 (assoc new-came node current-node)\n                 (assoc new-cost node node-cost)]\n                [new-front new-came new-cost])))\n          [frontier came-from cost-so-far]\n          neighbors))&quot;, :offset 568, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn pathfind\n  [level start-node end-node]\n  (let [graph (path-graph level start-node end-node)]\n    (if (get graph end-node)\n      (loop [search-node end-node\n             path        [end-node]]\n        (let [node-contents (get graph search-node)]\n          (if (= :start node-contents)\n            (reverse path)\n            (recur node-contents (conj path node-contents)))))\n      \&quot;nope!\&quot;)))&quot;, :offset 397, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(def testmap\n  [[1 1 1 1 1 1 1 1]\n   [9 9 9 9 1 1 1 1]\n   [1 1 9 1 1 1 1 1]\n   [1 1 9 1 9 1 1 1]\n   [1 9 9 9 9 1 1 1]\n   [1 1 1 1 1 1 1 1]])&quot;, :offset 140, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(def testmap1\n  [[1 1 1 1 1] \n   [9 9 9 9 1] \n   [1 1 9 1 1]\n   [1 1 9 1 9] \n   [1 9 9 9 9]\n   [1 1 1 1 1]])&quot;, :offset 108, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(def testmap1\n  [[1 1 1 1 1]\n   [9 9 9 9 1]\n   [1 1 9 1 1]\n   [1 1 9 1 9]\n   [1 9 9 9 9]\n   [1 1 1 1 1]])&quot;, :offset 105, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn pathfind\n  \&quot;For a given start and end node,\n  get the seq of [x y] coords from start to end.\&quot;\n  [level start-node end-node]\n  (let [graph (path-graph level start-node end-node)]\n    (if (get graph end-node)\n      (loop [search-node end-node\n             path        [end-node]]\n        (let [{:keys [prev-node]} (get graph search-node)]\n          (if (= :start prev-node)\n            (reverse path)\n            (recur prev-node (conj path prev-node)))))\n      graph)))&quot;, :offset 474, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn pathfind\n  \&quot;For a given start and end node,\n  get the seq of [x y] coords from start to end.\&quot;\n  [level start-node end-node]\n  (let [graph (path-graph level start-node end-node)]\n    (if (get graph end-node)\n      (loop [search-node end-node\n             path        [end-node]]\n        (let [{:keys [prev-node]} (get graph search-node)]\n          (if (= :start prev-node)\n            {:result :success :path (reverse path)}\n            (recur prev-node (conj path prev-node)))))\n      graph)))&quot;, :offset 499, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(def testmap2\n  [[1 1 1 1 1 1 1 1]\n   [9 9 9 9 1 1 1 1]\n   [1 1 9 1 1 1 1 1]\n   [1 1 9 1 9 1 1 1]\n   [1 9 9 9 9 1 1 1]\n   [1 1 1 1 1 1 1 1]])&quot;, :offset 141, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(count {:hello :world})&quot;, :offset 23, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(count {:hello :world :im :here})&quot;, :offset 33, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(def testmap1\n  [[1 9 1 1 1]\n   [9 9 9 9 1]\n   [1 1 9 1 1]\n   [1 1 9 1 9]\n   [1 9 9 9 9]\n   [1 1 1 1 1]])&quot;, :offset 105, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn pathfind\n  \&quot;For a given start and end node,\n  get the seq of [x y] coords from start to end.\&quot;\n  [level start-node end-node]\n  (let [graph (path-graph level start-node end-node)]\n    (cond\n      (= 1 (count graph))\n      {:result :no-move :path []}\n      (get graph end-node)\n      (loop [search-node end-node\n             path        [end-node]]\n        (let [{:keys [prev-node]} (get graph search-node)]\n          (if (= :start prev-node)\n            {:result :success :path (reverse path)}\n            (recur prev-node (conj path prev-node)))))\n      :else\n      {:result :nearest :path graph})))&quot;, :offset 604, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn pathfind\n  \&quot;For a given start and end node,\n  get the seq of [x y] coords from start to end.\&quot;\n  [level start-node end-node]\n  (let [graph (path-graph level start-node end-node)]\n    (cond\n      (= 1 (count graph))\n      {:result :no-move :path []}\n      (get graph end-node)\n      (loop [search-node end-node\n             path        [end-node]]\n        (let [{:keys [prev-node]} (get graph search-node)]\n          (if (= :start prev-node)\n            {:result :success :path (reverse path)}\n            (recur prev-node (conj path prev-node)))))\n      :else\n      {:result :nearest :path (reduce (fn [acc x] (if (&lt; acc\n                                                         (:est-dist x))\n                                                      x \n                                                      acc))\n                                      (vals graph))})))&quot;, :offset 870, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(def testmap2\n  [[1 1 1 1 1 1 1 1 1 1 1 1]\n   [9 9 9 9 1 1 1 1 1 1 1 1]\n   [1 1 9 1 1 1 1 1 1 1 1 1]\n   [1 1 9 1 9 1 1 1 1 1 1 1]\n   [1 9 9 9 9 1 1 1 1 1 1 1]\n   [9 9 9 9 9 1 1 1 1 1 1 1]\n   [1 9 9 9 9 1 1 1 1 1 1 1]\n   [1 9 9 9 9 1 1 1 1 1 1 1]\n   [1 9 9 9 9 1 1 1 1 1 1 1]\n   [1 1 1 1 1 1 1 1 1 1 1 1]])&quot;, :offset 305, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn graph-&gt;pathseq\n  [graph end-node]\n  (loop [search-node end-node\n         path        [end-node]]\n    (let [{:keys [prev-node]} (get graph search-node)]\n      (if (= :start prev-node)\n        (reverse path)\n        (recur prev-node (conj path prev-node))))))&quot;, :offset 263, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn pathfind\n  \&quot;For a given start and end node,\n  get the seq of [x y] coords from start to end.\&quot;\n  [level start-node end-node]\n  (let [graph (path-graph level start-node end-node)]\n    (cond\n      (= 1 (count graph))\n      {:result :no-move :path []}\n      (get graph end-node)\n      {:result :success :path (graph-&gt;pathseq graph end-node)}\n      :else\n      {:result :nearest :path (reduce (fn [acc x] (if (&lt; acc\n                                                         (:est-dist x))\n                                                      x\n                                                      acc))\n                                      (vals graph))})))&quot;, :offset 660, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(def testmap2\n  [[1 1 1 1 1 1 1 1 1 1 1 1]\n   [9 9 9 9 1 1 1 1 1 1 1 1]\n   [1 1 9 1 1 1 1 1 1 1 1 1]\n   [1 1 9 1 9 1 1 1 1 1 1 1]\n   [1 9 9 9 9 1 1 1 1 1 1 1]\n   [1 9 9 9 9 1 1 1 1 1 1 1]\n   [1 9 9 9 9 1 1 1 1 1 1 1]\n   [1 9 9 9 9 1 1 1 1 1 1 1]\n   [1 9 9 9 9 1 1 1 1 1 1 1]\n   [1 1 1 1 1 1 1 1 1 1 1 1]])&quot;, :offset 305, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn pathfind\n  \&quot;For a given start and end node,\n  get the seq of [x y] coords from start to end.\&quot;\n  [level start-node end-node]\n  (let [graph (path-graph level start-node end-node)]\n    (cond\n      (= 1 (count graph))\n      {:result :no-move :path []}\n      (get graph end-node)\n      {:result :success :path (graph-&gt;pathseq graph end-node)}\n      :else\n      graph\n      #_{:result :nearest :path (graph-&gt;pathseq graph\n                                                (-&gt;&gt; graph vals (max-key :est-distance)))})))&quot;, :offset 515, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(def g (pathfind testmap1 [0 0 ] [1 2]))&quot;, :offset 40, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(def testmap1\n  [[1 1 1 1 1]\n   [9 9 9 9 9]\n   [1 1 9 1 1]\n   [1 1 9 1 9]\n   [1 9 9 9 9]\n   [1 1 1 1 1]])&quot;, :offset 105, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;g&quot;, :offset 1, :ns &quot;cljs.user&quot;} {:command &quot;(println g)&quot;, :offset 11, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(def gg {[0 0] {:prev-node :start, :est-distance 3},\n           [1 0] {:prev-node [0 0], :est-distance 4},\n           [2 0] {:prev-node [1 0], :est-distance 4},\n           [3 0] {:prev-node [2 0], :est-distance 6},\n           [4 0] {:prev-node [3 0], :est-distance 8}})&quot;, :offset 269, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(max-key :est-distance gg)&quot;, :offset 26, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(apply max-key :est-distance gg)&quot;, :offset 32, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn pathfind\n  \&quot;For a given start and end node,\n  get the seq of [x y] coords from start to end.\&quot;\n  [level start-node end-node]\n  (let [graph (path-graph level start-node end-node)]\n    (cond\n      (= 1 (count graph))\n      {:result :no-move :path []}\n      (get graph end-node)\n      {:result :success :path (graph-&gt;pathseq graph end-node)}\n      :else\n      graph\n      {:result :nearest :path (graph-&gt;pathseq graph\n                                              (first (apply max-key :est-distance graph)))})))&quot;, :offset 514, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn pathfind\n  \&quot;For a given start and end node,\n  get the seq of [x y] coords from start to end.\&quot;\n  [level start-node end-node]\n  (let [graph (path-graph level start-node end-node)]\n    (cond\n      (= 1 (count graph))\n      {:result :no-move :path []}\n      (get graph end-node)\n      {:result :success :path (graph-&gt;pathseq graph end-node)}\n      :else\n      {:result :nearest :path (graph-&gt;pathseq graph\n                                              (first (apply max-key :est-distance graph)))})))&quot;, :offset 502, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(ns proto-crawl.rot-js.astar\n  (:require [tailrecursion.priority-map :as priority]\n            [cljs.spec.alpha :as s]))&quot;, :offset 120, :ns &quot;cljs.user&quot;} {:command &quot;(pathfind testmap2 [0 0] [1 2])&quot;, :offset 31, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(s/def ::path (s/coll-of (s/tuple int? int?)))&quot;, :offset 46, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(s/def ::result #{:success :nearest :no-path})&quot;, :offset 46, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(s/def ::pathfinding-result (s/keys :req-un [::result ::path]))&quot;, :offset 63, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn pathfind\n  \&quot;For a given start and end node,\n  get the seq of [x y] coords from start to end.\&quot;\n  [level start-node end-node]\n  {:post [(s/assert ::pathfinding-result %)]}\n  (let [graph (path-graph level start-node end-node)]\n    (cond\n      (= 1 (count graph))\n      {:result :no-move :path []}\n      (get graph end-node)\n      {:result :success :path (graph-&gt;pathseq graph end-node)}\n      :else\n      {:result :nearest :path (graph-&gt;pathseq graph\n                                              (first (apply max-key :est-distance graph)))})))&quot;, :offset 548, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(pathfind testmap1 [0 0] [1 2])&quot;, :offset 31, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(ns proto-crawl.rot-js.astar\n  (:require [tailrecursion.priority-map :as priority]\n            [proto-crawl.specs.pathable :as p]\n            [cljs.spec.alpha :as s]))&quot;, :offset 167, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn pathfind\n  \&quot;For a given start and end node,\n  get the seq of [x y] coords from start to end.\&quot;\n  [level pathable-cb? start-node end-node]\n  {:post [(s/assert ::pathfinding-result %)]}\n  (let [graph (path-graph level pathable-cb? start-node end-node)]\n    (cond\n      (= 1 (count graph))\n      {:result :no-move :path []}\n      (get graph end-node)\n      {:result :success :path (graph-&gt;pathseq graph end-node)}\n      :else\n      {:result :nearest :path (graph-&gt;pathseq graph\n                                              (first (apply max-key :est-distance graph)))})))&quot;, :offset 574, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn path-graph\n  \&quot;For a given start and end node, get the backtrack graph of\n  pos =&gt; tile-moved-from.\n   Internally, we use three vars to track the path graph:\n   - frontier, a priority map of which nodes need to be evaluated\n   (with priority to nodes more likely to be on the correct path)\n   - came-from, a map of the path we are walking. Keys are coords,\n   vals are a map of {:prev-node =&gt; coord, :est-distance(to goal) int}\n   - cost-so-far, a map of {coord =&gt; int} showing the cost of\n   moving to a given node from start.\&quot;\n  [level pathable-cb? start-node end-node]\n  (loop [frontier    (priority/priority-map start-node 0)\n         came-from   {start-node {:prev-node    :start\n                                  :est-distance (manhattan-distance start-node\n                                                                    end-node)}}\n         cost-so-far {start-node 0}]\n    (if (or (empty? frontier)\n            (= end-node (-&gt; frontier peek first)))\n      came-from\n      (let [current             (-&gt; frontier peek first)\n            ;; TODO give reachable-neighbors a callback fn\n            ;; so passability isn't hardcoded (in practice will check\n            ;; ::p/passable? on nodes).\n            reachable-neighbors (remove #(or (nil? (contents level %)) \n                                             pathable-cb?)\n                                        (neighbors current))\n            [new-front new-came-from new-cost-so-far] (evaluate-neighbors current\n                                                                          reachable-neighbors\n                                                                          (pop frontier)\n                                                                          came-from\n                                                                          cost-so-far\n                                                                          end-node)]\n        (recur new-front new-came-from new-cost-so-far)))))&quot;, :offset 1980, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn path-graph\n  \&quot;For a given start and end node, get the backtrack graph of\n  pos =&gt; tile-moved-from.\n   Internally, we use three vars to track the path graph:\n   - frontier, a priority map of which nodes need to be evaluated\n   (with priority to nodes more likely to be on the correct path)\n   - came-from, a map of the path we are walking. Keys are coords,\n   vals are a map of {:prev-node =&gt; coord, :est-distance(to goal) int}\n   - cost-so-far, a map of {coord =&gt; int} showing the cost of\n   moving to a given node from start.\&quot;\n  [level pathable-cb? start-node end-node]\n  (loop [frontier    (priority/priority-map start-node 0)\n         came-from   {start-node {:prev-node    :start\n                                  :est-distance (manhattan-distance start-node\n                                                                    end-node)}}\n         cost-so-far {start-node 0}]\n    (if (or (empty? frontier)\n            (= end-node (-&gt; frontier peek first)))\n      came-from\n      (let [current             (-&gt; frontier peek first)\n            ;; TODO give reachable-neighbors a callback fn\n            ;; so passability isn't hardcoded (in practice will check\n            ;; ::p/passable? on nodes).\n            reachable-neighbors (filter #(or (not (nil? (contents level %)))\n                                             pathable-cb?)\n                                        (neighbors current))\n            [new-front new-came-from new-cost-so-far] (evaluate-neighbors current\n                                                                          reachable-neighbors\n                                                                          (pop frontier)\n                                                                          came-from\n                                                                          cost-so-far\n                                                                          end-node)]\n        (recur new-front new-came-from new-cost-so-far)))))&quot;, :offset 1985, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn path-graph\n  \&quot;For a given start and end node, get the backtrack graph of\n  pos =&gt; tile-moved-from.\n   Internally, we use three vars to track the path graph:\n   - frontier, a priority map of which nodes need to be evaluated\n   (with priority to nodes more likely to be on the correct path)\n   - came-from, a map of the path we are walking. Keys are coords,\n   vals are a map of {:prev-node =&gt; coord, :est-distance(to goal) int}\n   - cost-so-far, a map of {coord =&gt; int} showing the cost of\n   moving to a given node from start.\&quot;\n  [level pathable-cb? start-node end-node]\n  (loop [frontier    (priority/priority-map start-node 0)\n         came-from   {start-node {:prev-node    :start\n                                  :est-distance (manhattan-distance start-node\n                                                                    end-node)}}\n         cost-so-far {start-node 0}]\n    (if (or (empty? frontier)\n            (= end-node (-&gt; frontier peek first)))\n      came-from\n      (let [current             (-&gt; frontier peek first)\n            ;; TODO give reachable-neighbors a callback fn\n            ;; so passability isn't hardcoded (in practice will check\n            ;; ::p/passable? on nodes).\n            reachable-neighbors (filter #(or (-&gt;&gt; % (contents level) nil? not)\n                                             pathable-cb?)\n                                        (neighbors current))\n            [new-front new-came-from new-cost-so-far] (evaluate-neighbors current\n                                                                          reachable-neighbors\n                                                                          (pop frontier)\n                                                                          came-from\n                                                                          cost-so-far\n                                                                          end-node)]\n        (recur new-front new-came-from new-cost-so-far)))))&quot;, :offset 1987, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn path-graph\n  \&quot;For a given start and end node, get the backtrack graph of\n  pos =&gt; tile-moved-from.\n   Internally, we use three vars to track the path graph:\n   - frontier, a priority map of which nodes need to be evaluated\n   (with priority to nodes more likely to be on the correct path)\n   - came-from, a map of the path we are walking. Keys are coords,\n   vals are a map of {:prev-node =&gt; coord, :est-distance(to goal) int}\n   - cost-so-far, a map of {coord =&gt; int} showing the cost of\n   moving to a given node from start.\&quot;\n  [level pathable-cb? start-node end-node]\n  (loop [frontier    (priority/priority-map start-node 0)\n         came-from   {start-node {:prev-node    :start\n                                  :est-distance (manhattan-distance start-node\n                                                                    end-node)}}\n         cost-so-far {start-node 0}]\n    (if (or (empty? frontier)\n            (= end-node (-&gt; frontier peek first)))\n      came-from\n      (let [current             (-&gt; frontier peek first)\n            ;; TODO give reachable-neighbors a callback fn\n            ;; so passability isn't hardcoded (in practice will check\n            ;; ::p/passable? on nodes).\n            reachable-neighbors (filter (partial pathable-cb? level) (neighbors current))\n            [new-front new-came-from new-cost-so-far] (evaluate-neighbors current\n                                                                          reachable-neighbors\n                                                                          (pop frontier)\n                                                                          came-from\n                                                                          cost-so-far\n                                                                          end-node)]\n        (recur new-front new-came-from new-cost-so-far)))))&quot;, :offset 1878, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(pathfind testmap1 #(or (not (nil? (contents %1 %2)))\n                          (not (= 9 (contents %1 %2))))\n                     [0 0] [1 2])&quot;, :offset 143, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(contents testmap [0 1])&quot;, :offset 24, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(pathfind testmap1 #(and (not (nil? (contents %1 %2)))\n                           (not (= 9 (contents %1 %2))))\n                     [0 0] [1 2])&quot;, :offset 145, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn contents\n  \&quot;Only used for testing.\&quot;\n  [level [x y]]\n  (get (get level y) x))&quot;, :offset 82, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn graph-&gt;pathseq\n  \&quot;Turn a graph into the sequence of steps from :start to end-node,\n  backtracking from end-node.\&quot;\n  [graph end-node]\n  (loop [search-node end-node\n         path        [end-node]]\n    (let [{:keys [prev-node]} (get graph search-node)]\n      (if (= :start prev-node)\n        (reverse path)\n        (recur prev-node (conj path prev-node))))))&quot;, :offset 362, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn path-graph\n  \&quot;For a given start and end node, get the backtrack graph of\n  pos =&gt; tile-moved-from.\n   Internally, we use three vars to track the path graph:\n   - frontier, a priority map of which nodes need to be evaluated\n   (with priority to nodes more likely to be on the correct path)\n   - came-from, a map of the path we are walking. Keys are coords,\n   vals are a map of {:prev-node =&gt; coord, :est-distance(to goal) int}\n   - cost-so-far, a map of {coord =&gt; int} showing the cost of\n   moving to a given node from start.\&quot;\n  [level pathable-cb? start-node end-node]\n  (loop [frontier    (priority/priority-map start-node 0)\n         came-from   {start-node {:prev-node    :start\n                                  :est-distance (manhattan-distance start-node\n                                                                    end-node)}}\n         cost-so-far {start-node 0}]\n    (if (or (empty? frontier)\n            (= end-node (-&gt; frontier peek first)))\n      came-from\n      (let [current             (-&gt; frontier peek first)\n            ;; TODO give reachable-neighbors a callback fn\n            ;; so passability isn't hardcoded (in practice will check\n            ;; ::p/passable? on nodes).\n            reachable-neighbors (filter pathable-cb? (neighbors current))\n            [new-front new-came-from new-cost-so-far] (evaluate-neighbors current\n                                                                          reachable-neighbors\n                                                                          (pop frontier)\n                                                                          came-from\n                                                                          cost-so-far\n                                                                          end-node)]\n        (recur new-front new-came-from new-cost-so-far)))))&quot;, :offset 1862, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn path-graph\n  \&quot;For a given start and end node, get the backtrack graph of\n  pos =&gt; tile-moved-from.\n   Internally, we use three vars to track the path graph:\n   - frontier, a priority map of which nodes need to be evaluated\n   (with priority to nodes more likely to be on the correct path)\n   - came-from, a map of the path we are walking. Keys are coords,\n   vals are a map of {:prev-node =&gt; coord, :est-distance(to goal) int}\n   - cost-so-far, a map of {coord =&gt; int} showing the cost of\n   moving to a given node from start.\&quot;\n  [start-node end-node pathable-cb?]\n  (loop [frontier    (priority/priority-map start-node 0)\n         came-from   {start-node {:prev-node    :start\n                                  :est-distance (manhattan-distance start-node\n                                                                    end-node)}}\n         cost-so-far {start-node 0}]\n    (if (or (empty? frontier)\n            (= end-node (-&gt; frontier peek first)))\n      came-from\n      (let [current             (-&gt; frontier peek first)\n            ;; TODO give reachable-neighbors a callback fn\n            ;; so passability isn't hardcoded (in practice will check\n            ;; ::p/passable? on nodes).\n            reachable-neighbors (filter pathable-cb? (neighbors current))\n            [new-front new-came-from new-cost-so-far] (evaluate-neighbors current\n                                                                          reachable-neighbors\n                                                                          (pop frontier)\n                                                                          came-from\n                                                                          cost-so-far\n                                                                          end-node)]\n        (recur new-front new-came-from new-cost-so-far)))))&quot;, :offset 1856, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn pathfind\n  \&quot;For a given start and end node,\n  get the seq of [x y] coords from start to end.\n  Pathable-cb will be passed `level` and a node position.\n  Return true if that node is passable, false otherwise.\&quot;\n  [start-node end-node pathable-cb?]\n  {:post [(s/assert ::pathfinding-result %)]}\n  (let [graph (path-graph? start-node end-node pathable-cb?)]\n    (cond\n      (= 1 (count graph))\n      {:result :no-move :path []}\n      (get graph end-node)\n      {:result :success :path (graph-&gt;pathseq graph end-node)}\n      :else\n      {:result :nearest :path (graph-&gt;pathseq graph\n                                              (first (apply max-key :est-distance graph)))})))&quot;, :offset 678, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn pathfind\n  \&quot;For a given start and end node,\n  get the seq of [x y] coords from start to end.\n  Pathable-cb will be passed `level` and a node position.\n  Return true if that node is passable, false otherwise.\&quot;\n  [start-node end-node pathable-cb?]\n  {:post [(s/assert ::pathfinding-result %)]}\n  (let [graph (path-graph start-node end-node pathable-cb?)]\n    (cond\n      (= 1 (count graph))\n      {:result :no-move :path []}\n      (get graph end-node)\n      {:result :success :path (graph-&gt;pathseq graph end-node)}\n      :else\n      {:result :nearest :path (graph-&gt;pathseq graph\n                                              (first (apply max-key :est-distance graph)))})))&quot;, :offset 677, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(ns proto-crawl.entities.actions\n  \&quot;Each entity operation takes an ID (the ID of the acting entity) and the DB\n  and returns an updated(?) DB.\n  thus, we can chain actions:\n  (-&gt;&gt; db (step-toward-player id) (step-toward-player id))\n  (-&gt;&gt; db (step-toward-player id) (attack-player id))\n  (-&gt;&gt; db (step-toward-or-attack-player id) (buff-self id)) \&quot;\n  (:require [clojure.set :as set]\n            [cljs.spec.alpha :as s]\n            [proto-crawl.rot-js.pathfinding :as pathfinding]\n            [proto-crawl.rot-js.astar :as astar]\n            [proto-crawl.specs.game-state :as state]\n            [proto-crawl.specs.pathable :as p]))&quot;, :offset 629, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn step-toward-player\n  \&quot;Take a step toward player, if able.\&quot;\n  [id [run? db :as event-result]]\n  {:pre  [(s/assert ::state/event-result event-result)]\n   :post [(s/assert ::state/event-result %)]}\n  (if run?\n    (let [self      (get-entity id db)\n          collision (pathfinding/db-&gt;collision-map db :exclude-entity self)\n          player    (:player db)\n          path      (astar/pathfind (::p/pos self)\n                                    (::p/pos player)\n                                    (simple-path-cb collision))]\n      (if (and path\n               (not= (first path)\n                     (::p/pos player)))\n        [true (pack-ent-in-db db (assoc self ::p/pos (first path)))]\n        [false db]))\n    [false db]))&quot;, :offset 729, :ns &quot;proto-crawl.entities.actions&quot;} {:command &quot;(defn step-toward-player\n  \&quot;Take a step toward player, if able.\&quot;\n  [id [run? db :as event-result]]\n  {:pre  [(s/assert ::state/event-result event-result)]\n   :post [(s/assert ::state/event-result %)]}\n  (if run?\n    (let [self      (get-entity id db)\n          collision (pathfinding/db-&gt;collision-map db :exclude-entity self)\n          player    (:player db)\n          {:keys [path result]} (astar/pathfind (::p/pos self)\n                                                (::p/pos player)\n                                                (simple-path-cb collision))]\n      (if (not= result :no-path)\n        [true (pack-ent-in-db db (assoc self ::p/pos (first path)))]\n        [false db]))\n    [false db]))&quot;, :offset 704, :ns &quot;proto-crawl.entities.actions&quot;} {:command &quot;(defn simple-path-cb\n  [collision]\n  (fn [[x y]]\n    (println \&quot;in simple-path-cb at loc: \&quot; [x y])\n    (let [tile      (get collision [x y])\n          passable? (::p/passable? tile)]\n      passable?)))&quot;, :offset 200, :ns &quot;proto-crawl.entities.actions&quot;} {:command &quot;(defn simple-path-cb\n  [collision]\n  (fn [[x y]]\n    (let [tile      (get collision [x y])\n          passable? (::p/passable? tile)]\n      passable?)))&quot;, :offset 151, :ns &quot;proto-crawl.entities.actions&quot;} {:command &quot;(defn step-toward-player\n  \&quot;Take a step toward player, if able.\&quot;\n  [id [run? db :as event-result]]\n  {:pre  [(s/assert ::state/event-result event-result)]\n   :post [(s/assert ::state/event-result %)]}\n  (if run?\n    (let [self      (get-entity id db)\n          collision (pathfinding/db-&gt;collision-map db :exclude-entity self)\n          player    (:player db)\n          {:keys [path result]} (astar/pathfind (::p/pos self)\n                                                (::p/pos player)\n                                                (simple-path-cb collision))]\n      (println {:path path :result result})\n      (if (not= result :no-path)\n        [true (pack-ent-in-db db (assoc self ::p/pos (first path)))]\n        [false db]))\n    [false db]))&quot;, :offset 748, :ns &quot;proto-crawl.entities.actions&quot;} {:command &quot;(defn step-toward-player\n  \&quot;Take a step toward player, if able.\&quot;\n  [id [run? db :as event-result]]\n  {:pre  [(s/assert ::state/event-result event-result)]\n   :post [(s/assert ::state/event-result %)]}\n  (if run?\n    (let [self      (get-entity id db)\n          collision (pathfinding/db-&gt;collision-map db :exclude-entity self)\n          player    (:player db)\n          {:keys [path result]} (astar/pathfind (::p/pos self)\n                                                (::p/pos player)\n                                                (simple-path-cb collision))]\n      (println {:path path :result result})\n      (println (not= result :no-path))\n      (if (not= result :no-path)\n        [true (pack-ent-in-db db (assoc self ::p/pos (first path)))]\n        [false db]))\n    [false db]))&quot;, :offset 787, :ns &quot;proto-crawl.entities.actions&quot;} {:command &quot;(defn step-toward-player\n  \&quot;Take a step toward player, if able.\&quot;\n  [id [run? db :as event-result]]\n  {:pre  [(s/assert ::state/event-result event-result)]\n   :post [(s/assert ::state/event-result %)]}\n  (if run?\n    (let [self      (get-entity id db)\n          collision (pathfinding/db-&gt;collision-map db :exclude-entity self)\n          player    (:player db)\n          {:keys [path result]} (astar/pathfind (::p/pos self)\n                                                (::p/pos player)\n                                                (simple-path-cb collision))]\n      (println {:path path :result result})\n      (println (not= result :no-path))\n      (if (not= result :no-path)\n        [true (pack-ent-in-db db (assoc self ::p/pos (second path)))]\n        [false db]))\n    [false db]))&quot;, :offset 788, :ns &quot;proto-crawl.entities.actions&quot;} {:command &quot;(s/def ::result #{:success :nearest :no-move})&quot;, :offset 46, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn step-toward-player\n  \&quot;Take a step toward player, if able.\&quot;\n  [id [run? db :as event-result]]\n  {:pre  [(s/assert ::state/event-result event-result)]\n   :post [(s/assert ::state/event-result %)]}\n  (if run?\n    (let [self      (get-entity id db)\n          collision (pathfinding/db-&gt;collision-map db :exclude-entity self)\n          player    (:player db)\n          {:keys [path result]} (astar/pathfind (::p/pos self)\n                                                (::p/pos player)\n                                                (simple-path-cb collision))]\n      (println {:path path :result result})\n      (println (not= result :no-move))\n      (if (not= result :no-move)\n        [true (pack-ent-in-db db (assoc self ::p/pos (second path)))]\n        [false db]))\n    [false db]))&quot;, :offset 788, :ns &quot;proto-crawl.entities.actions&quot;} {:command &quot;(defn init-game-state\n  []\n  {:post [(s/assert ::game/state %)]}\n  (let [level (map-loader/loader (random-map-name))]\n    {:entities    (add-entities 1 level)\n     :current-map level\n     :metadata    {:map-config    {}\n                   :show-alt?     false\n                   :viewport-size 12}\n     :player      (init-player)}))&quot;, :offset 332, :ns &quot;proto-crawl.re-frame.state&quot;} {:command &quot;(defn step-toward-player\n  \&quot;Take a step toward player, if able.\&quot;\n  [id [run? db :as event-result]]\n  {:pre  [(s/assert ::state/event-result event-result)]\n   :post [(s/assert ::state/event-result %)]}\n  (if run?\n    (let [self      (get-entity id db)\n          collision (pathfinding/db-&gt;collision-map db \n                                                   :exclude-entity self\n                                                   :exclude-player true)\n          player    (:player db)\n          {:keys [path result]} (astar/pathfind (::p/pos self)\n                                                (::p/pos player)\n                                                (simple-path-cb collision))]\n      (println {:path path :result result})\n      (println (not= result :no-move))\n      (if (not= result :no-move)\n        [true (pack-ent-in-db db (assoc self ::p/pos (second path)))]\n        [false db]))\n    [false db]))&quot;, :offset 912, :ns &quot;proto-crawl.entities.actions&quot;} {:command &quot;(defn init-game-state\n  []\n  {:post [(s/assert ::game/state %)]}\n  (let [level (map-loader/loader (random-map-name))]\n    {:entities    (add-entities 3 level)\n     :current-map level\n     :metadata    {:map-config    {}\n                   :show-alt?     false\n                   :viewport-size 12}\n     :player      (init-player)}))&quot;, :offset 332, :ns &quot;proto-crawl.re-frame.state&quot;} {:command &quot;(s/def ::result #{:success :nearest :no-move :at-target})&quot;, :offset 57, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn step-toward-player\n  \&quot;Take a step toward player, if able.\&quot;\n  [id [run? db :as event-result]]\n  {:pre  [(s/assert ::state/event-result event-result)]\n   :post [(s/assert ::state/event-result %)]}\n  (if run?\n    (let [self      (get-entity id db)\n          collision (pathfinding/db-&gt;collision-map db\n                                                   :exclude-entity self\n                                                   :exclude-player true)\n          player    (:player db)\n          {:keys [path result]} (astar/pathfind (::p/pos self)\n                                                (::p/pos player)\n                                                (simple-path-cb collision))]\n      (println {:path path :result result})\n      (println (not= result :no-move))\n      (if (or (not= result :no-move)\n              (not= result :at-target))\n        [true (pack-ent-in-db db (assoc self ::p/pos (second path)))]\n        [false db]))\n    [false db]))&quot;, :offset 955, :ns &quot;proto-crawl.entities.actions&quot;} {:command &quot;(defn step-toward-player\n  \&quot;Take a step toward player, if able.\&quot;\n  [id [run? db :as event-result]]\n  {:pre  [(s/assert ::state/event-result event-result)]\n   :post [(s/assert ::state/event-result %)]}\n  (if run?\n    (let [self      (get-entity id db)\n          collision (pathfinding/db-&gt;collision-map db\n                                                   :exclude-entity self\n                                                   :exclude-player true)\n          player    (:player db)\n          {:keys [path result]} (astar/pathfind (::p/pos self)\n                                                (::p/pos player)\n                                                (simple-path-cb collision))]\n      (println {:path path :result result})\n      (println (not= result :no-move))\n      (if (and (not= result :no-move)\n               (not= result :at-target))\n        [true (pack-ent-in-db db (assoc self ::p/pos (second path)))]\n        [false db]))\n    [false db]))&quot;, :offset 957, :ns &quot;proto-crawl.entities.actions&quot;} {:command &quot;(defn step-toward-player\n  \&quot;Take a step toward player, if able.\&quot;\n  [id [run? db :as event-result]]\n  {:pre  [(s/assert ::state/event-result event-result)]\n   :post [(s/assert ::state/event-result %)]}\n  (if run?\n    (let [self      (get-entity id db)\n          collision (pathfinding/db-&gt;collision-map db\n                                                   :exclude-entity self\n                                                   :exclude-player true)\n          player    (:player db)\n          {:keys [path result]} (astar/pathfind (::p/pos self)\n                                                (::p/pos player)\n                                                (simple-path-cb collision))]\n      (println {:path path :result result})\n      (println result)\n      (if (and (not= result :no-move)\n               (not= result :at-target))\n        [true (pack-ent-in-db db (assoc self ::p/pos (second path)))]\n        [false db]))\n    [false db]))&quot;, :offset 941, :ns &quot;proto-crawl.entities.actions&quot;} {:command &quot;(defn step-toward-player\n  \&quot;Take a step toward player, if able.\&quot;\n  [id [run? db :as event-result]]\n  {:pre  [(s/assert ::state/event-result event-result)]\n   :post [(s/assert ::state/event-result %)]}\n  (if run?\n    (let [self      (get-entity id db)\n          collision (pathfinding/db-&gt;collision-map db\n                                                   :exclude-entity self\n                                                   :exclude-player true)\n          player    (:player db)\n          {:keys [path result]} (astar/pathfind (::p/pos self)\n                                                (::p/pos player)\n                                                (simple-path-cb collision))]\n      (println {:path path :result result})\n      (if (and (not= result :no-move)\n               (not= result :at-target))\n        [true (pack-ent-in-db db (assoc self ::p/pos (second path)))]\n        [false db]))\n    [false db]))&quot;, :offset 918, :ns &quot;proto-crawl.entities.actions&quot;} {:command &quot;(defn pathfind\n  \&quot;For a given start and end node,\n  get the seq of [x y] coords from start to end.\n  Pathable-cb will be passed `level` and a node position.\n  Return true if that node is passable, false otherwise.\&quot;\n  [start-node end-node pathable-cb?]\n  {:post [(s/assert ::pathfinding-result %)]}\n  (let [graph (path-graph start-node end-node pathable-cb?)\n        path (graph-&gt;pathseq graph end-node)]\n    (cond\n      (= 1 (count path)) ;; can't move anywhere\n      {:result :no-move :path []}\n      (= 2 (count path)) ;; next move is target\n      {:result :at-target :path (graph-&gt;pathseq graph end-node)}\n      (get graph end-node) ;; can reach target\n      {:result :success :path (graph-&gt;pathseq graph end-node)}\n      :else ;; blocked?\n      {:result :nearest :path (graph-&gt;pathseq graph\n                                              (first (apply max-key :est-distance graph)))})))&quot;, :offset 889, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn pathfind\n  \&quot;For a given start and end node,\n  get the seq of [x y] coords from start to end.\n  Pathable-cb will be passed `level` and a node position.\n  Return true if that node is passable, false otherwise.\&quot;\n  [start-node end-node pathable-cb?]\n  {:post [(s/assert ::pathfinding-result %)]}\n  (let [graph (path-graph start-node end-node pathable-cb?)\n        path (graph-&gt;pathseq graph end-node)]\n    (cond\n      (= 1 (count path)) ;; can't move anywhere\n      {:result :no-move :path []}\n      (= 2 (count path)) ;; next move is target\n      {:result :at-target :path path}\n      (get graph end-node) ;; can reach target\n      {:result :success :path path}\n      :else ;; blocked?\n      {:result :nearest :path (graph-&gt;pathseq graph\n                                              (first (apply max-key :est-distance graph)))})))&quot;, :offset 835, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn step-toward-player\n  \&quot;Take a step toward player, if able.\&quot;\n  [id [run? db :as event-result]]\n  {:pre  [(s/assert ::state/event-result event-result)]\n   :post [(s/assert ::state/event-result %)]}\n  (if run?\n    (let [self      (get-entity id db)\n          collision (pathfinding/db-&gt;collision-map db\n                                                   :exclude-entity self\n                                                   :exclude-player true)\n          player    (:player db)\n          {:keys [path result]} (astar/pathfind (::p/pos self)\n                                                (::p/pos player)\n                                                (simple-path-cb collision))]\n      (println {:path path :result result})\n      (if (or (not= result :no-move)\n              (not= result :at-target))\n        [true (pack-ent-in-db db (assoc self ::p/pos (second path)))]\n        [false db]))\n    [false db]))&quot;, :offset 916, :ns &quot;proto-crawl.entities.actions&quot;} {:command &quot;(defn pathfind\n  \&quot;For a given start and end node,\n  get the seq of [x y] coords from start to end.\n  Pathable-cb will be passed `level` and a node position.\n  Return true if that node is passable, false otherwise.\&quot;\n  [start-node end-node pathable-cb?]\n  {:post [(s/assert ::pathfinding-result %)]}\n  (let [graph (path-graph start-node end-node pathable-cb?)]\n    (cond\n      (= 1 (count graph)) ;; can't move anywhere\n      {:result :no-move :path []}\n      (= 2 (count graph)) ;; next move is target\n      {:result :at-target :path (graph-&gt;pathseq graph end-node)}\n      (get graph end-node) ;; can reach target\n      {:result :success :path (graph-&gt;pathseq graph end-node)}\n      :else ;; blocked?\n      {:result :nearest :path (graph-&gt;pathseq graph\n                                              (first (apply max-key :est-distance graph)))})))&quot;, :offset 846, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn pathfind\n  \&quot;For a given start and end node,\n  get the seq of [x y] coords from start to end.\n  Pathable-cb will be passed `level` and a node position.\n  Return true if that node is passable, false otherwise.\&quot;\n  [start-node end-node pathable-cb?]\n  {:post [(s/assert ::pathfinding-result %)]}\n  (let [graph (path-graph start-node end-node pathable-cb?)]\n    (cond\n      (= 1 (count graph)) ;; can't move anywhere\n      {:result :no-move :path []}\n      (= 2 (count (graph-&gt;pathseq graph end-node))) ;; next move is target\n      {:result :at-target :path (graph-&gt;pathseq graph end-node)}\n      (get graph end-node) ;; can reach target\n      {:result :success :path (graph-&gt;pathseq graph end-node)}\n      :else ;; blocked?\n      {:result :nearest :path (graph-&gt;pathseq graph\n                                              (first (apply max-key :est-distance graph)))})))&quot;, :offset 872, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn pathfind\n  \&quot;For a given start and end node,\n  get the seq of [x y] coords from start to end.\n  Pathable-cb will be passed `level` and a node position.\n  Return true if that node is passable, false otherwise.\&quot;\n  [start-node end-node pathable-cb?]\n  {:post [(s/assert ::pathfinding-result %)]}\n  (let [graph (path-graph start-node end-node pathable-cb?)\n        path (graph-&gt;pathseq graph end-node)]\n    (println path)\n    (println \&quot;graph count is \&quot; (count graph))\n    (cond\n      (= 1 (count graph)) ;; can't move anywhere\n      {:result :no-move :path []}\n      (= 2 (count (graph-&gt;pathseq graph end-node))) ;; next move is target\n      {:result :at-target :path (graph-&gt;pathseq graph end-node)}\n      (get graph end-node) ;; can reach target\n      {:result :success :path (graph-&gt;pathseq graph end-node)}\n      :else ;; blocked?\n      {:result :nearest :path (graph-&gt;pathseq graph\n                                              (first (apply max-key :est-distance graph)))})))&quot;, :offset 982, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn pathfind\n  \&quot;For a given start and end node,\n  get the seq of [x y] coords from start to end.\n  Pathable-cb will be passed `level` and a node position.\n  Return true if that node is passable, false otherwise.\&quot;\n  [start-node end-node pathable-cb?]\n  {:post [(s/assert ::pathfinding-result %)]}\n  (let [graph (path-graph start-node end-node pathable-cb?)\n        path (graph-&gt;pathseq graph end-node)]\n    (println path)\n    (println \&quot;graph count is \&quot; (count graph))\n    (cond\n      (= 1 (count path)) ;; can't move anywhere\n      {:result :no-move :path path}\n      (= 2 (count path)) ;; next move is target\n      {:result :at-target :path path}\n      (get graph end-node) ;; can reach target\n      {:result :success :path path}\n      :else ;; blocked?\n      {:result :nearest :path (graph-&gt;pathseq graph\n                                              (first (apply max-key :est-distance graph)))})))&quot;, :offset 902, :ns &quot;proto-crawl.rot-js.astar&quot;} {:command &quot;(defn step-toward-player\n  \&quot;Take a step toward player, if able.\&quot;\n  [id [run? db :as event-result]]\n  {:pre  [(s/assert ::state/event-result event-result)]\n   :post [(s/assert ::state/event-result %)]}\n  (if run?\n    (let [self      (get-entity id db)\n          collision (pathfinding/db-&gt;collision-map db\n                                                   :exclude-entity self\n                                                   :exclude-player true)\n          player    (:player db)\n          {:keys [path result]} (astar/pathfind (::p/pos self)\n                                                (::p/pos player)\n                                                (simple-path-cb collision))]\n      (if (or (not= result :no-move)\n              (not= result :at-target))\n        [true (pack-ent-in-db db (assoc self ::p/pos (second path)))]\n        [false db]))\n    [false db]))&quot;, :offset 872, :ns &quot;proto-crawl.entities.actions&quot;} {:command &quot;(ns proto-crawl.entities.actions\n  \&quot;Each entity operation takes an ID (the ID of the acting entity) and the DB\n  and returns an updated(?) DB.\n  thus, we can chain actions:\n  (-&gt;&gt; db (step-toward-player id) (step-toward-player id))\n  (-&gt;&gt; db (step-toward-player id) (attack-player id))\n  (-&gt;&gt; db (step-toward-or-attack-player id) (buff-self id)) \&quot;\n  (:require [clojure.set :as set]\n            [cljs.core.match :refer [match]]\n            [cljs.spec.alpha :as s]\n            [proto-crawl.rot-js.pathfinding :as pathfinding]\n            [proto-crawl.rot-js.astar :as astar]\n            [proto-crawl.specs.game-state :as state]\n            [proto-crawl.specs.pathable :as p]))&quot;, :offset 674, :ns &quot;cljs.user&quot;} {:command &quot;(shadow/repl :crawl)&quot;, :offset 19, :ns &quot;shadow.user&quot;}]}}</component>
  <component name="RunDashboard">
    <option name="ruleStates">
      <list>
        <RuleState>
          <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
        </RuleState>
        <RuleState>
          <option name="name" value="StatusDashboardGroupingRule" />
        </RuleState>
      </list>
    </option>
  </component>
  <component name="RunManager" selected="Clojure REPL.crawl shadow-cljs REPL">
    <configuration name="REPL for proto-crawl" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false" temporary="true">
      <module name="proto-crawl" />
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="DEPS" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="$PROJECT_DIR$" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Local" activateToolWindowBeforeRun="false">
      <setting name="replType" value="NREPL" />
      <setting name="execution" value="LEININGEN" />
      <module name="" />
      <setting name="jvmArgs" value="" />
      <setting name="parameters" value="" />
      <setting name="workingDir" value="" />
      <setting name="profiles" value="" />
      <setting name="aliases" value="" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ClojureREPL" factoryName="Remote" activateToolWindowBeforeRun="false">
      <setting name="host" value="localhost" />
      <setting name="port" value="3333" />
      <setting name="replType" value="0" />
      <module name="" />
      <method v="2" />
    </configuration>
    <configuration name="crawl shadow-cljs REPL" type="ClojureREPL" factoryName="Remote" activateToolWindowBeforeRun="false">
      <module name="proto-crawl" />
      <setting name="host" value="localhost" />
      <setting name="port" value="3333" />
      <setting name="replType" value="0" />
      <method v="2" />
    </configuration>
    <list>
      <item itemvalue="Clojure REPL.crawl shadow-cljs REPL" />
      <item itemvalue="Clojure REPL.REPL for proto-crawl" />
    </list>
    <recent_temporary>
      <list>
        <item itemvalue="Clojure REPL.REPL for proto-crawl" />
      </list>
    </recent_temporary>
  </component>
  <component name="SvnConfiguration">
    <configuration />
  </component>
  <component name="Vcs.Log.Tabs.Properties">
    <option name="TAB_STATES">
      <map>
        <entry key="MAIN">
          <value>
            <State>
              <option name="COLUMN_ORDER" />
            </State>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>